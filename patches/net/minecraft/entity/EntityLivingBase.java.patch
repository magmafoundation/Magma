--- ../src-base/minecraft/net/minecraft/entity/EntityLivingBase.java
+++ ../src-work/minecraft/net/minecraft/entity/EntityLivingBase.java
@@ -1,14 +1,11 @@
 package net.minecraft.entity;
 
+import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent;
+import com.google.common.base.Function;
 import com.google.common.base.Objects;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import java.util.Collection;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.UUID;
+import java.util.*;
 import javax.annotation.Nullable;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.block.Block;
@@ -19,32 +16,22 @@
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.enchantment.EnchantmentFrostWalker;
 import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.entity.ai.attributes.AbstractAttributeMap;
-import net.minecraft.entity.ai.attributes.AttributeMap;
-import net.minecraft.entity.ai.attributes.AttributeModifier;
-import net.minecraft.entity.ai.attributes.IAttribute;
-import net.minecraft.entity.ai.attributes.IAttributeInstance;
+import net.minecraft.entity.ai.EntityAISit;
+import net.minecraft.entity.ai.attributes.*;
 import net.minecraft.entity.item.EntityBoat;
 import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.item.EntityXPOrb;
 import net.minecraft.entity.passive.AbstractHorse;
-import net.minecraft.entity.passive.EntityWolf;
+import net.minecraft.entity.passive.EntityAnimal;
+import net.minecraft.entity.passive.EntityTameable;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.entity.projectile.EntityArrow;
-import net.minecraft.init.Blocks;
-import net.minecraft.init.Enchantments;
-import net.minecraft.init.Items;
-import net.minecraft.init.MobEffects;
-import net.minecraft.init.SoundEvents;
+import net.minecraft.init.*;
 import net.minecraft.inventory.EntityEquipmentSlot;
-import net.minecraft.item.EnumAction;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemArmor;
-import net.minecraft.item.ItemElytra;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTTagList;
+import net.minecraft.inventory.EntityEquipmentSlot.Type;
+import net.minecraft.item.*;
+import net.minecraft.nbt.*;
 import net.minecraft.network.datasync.DataParameter;
 import net.minecraft.network.datasync.DataSerializers;
 import net.minecraft.network.datasync.EntityDataManager;
@@ -55,42 +42,48 @@
 import net.minecraft.potion.PotionEffect;
 import net.minecraft.potion.PotionUtils;
 import net.minecraft.stats.StatList;
-import net.minecraft.util.CombatRules;
-import net.minecraft.util.CombatTracker;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EntityDamageSource;
-import net.minecraft.util.EntitySelectors;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.EnumHandSide;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.NonNullList;
-import net.minecraft.util.SoundEvent;
+import net.minecraft.util.*;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
+import net.minecraftforge.common.ForgeHooks;
+import net.minecraftforge.common.ISpecialArmor;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.entity.living.PotionEvent.PotionRemoveEvent;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.v1_12_R1.attribute.CraftAttributeMap;
+import org.bukkit.craftbukkit.v1_12_R1.entity.CraftPlayer;
+import org.bukkit.craftbukkit.v1_12_R1.event.CraftEventFactory;
+import org.bukkit.craftbukkit.v1_12_R1.inventory.CraftItemStack;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.event.entity.EntityRegainHealthEvent;
+import org.bukkit.event.entity.EntityResurrectEvent;
+import org.bukkit.event.entity.EntityTeleportEvent;
+import org.bukkit.event.player.PlayerItemConsumeEvent;
 
 public abstract class EntityLivingBase extends Entity
 {
     private static final Logger LOGGER = LogManager.getLogger();
     private static final UUID SPRINTING_SPEED_BOOST_ID = UUID.fromString("662A6B8D-DA3E-4C1C-8813-96EA6097278D");
     private static final AttributeModifier SPRINTING_SPEED_BOOST = (new AttributeModifier(SPRINTING_SPEED_BOOST_ID, "Sprinting speed boost", 0.30000001192092896D, 2)).setSaved(false);
-    public static final net.minecraft.entity.ai.attributes.IAttribute SWIM_SPEED = new net.minecraft.entity.ai.attributes.RangedAttribute(null, "forge.swimSpeed", 1.0D, 0.0D, 1024.0D).setShouldWatch(true);
+    public static final IAttribute SWIM_SPEED = new net.minecraft.entity.ai.attributes.RangedAttribute(null, "forge.swimSpeed", 1.0D, 0.0D, 1024.0D).setShouldWatch(true);
     protected static final DataParameter<Byte> HAND_STATES = EntityDataManager.<Byte>createKey(EntityLivingBase.class, DataSerializers.BYTE);
-    private static final DataParameter<Float> HEALTH = EntityDataManager.<Float>createKey(EntityLivingBase.class, DataSerializers.FLOAT);
+    public static final DataParameter<Float> HEALTH = EntityDataManager.<Float>createKey(EntityLivingBase.class, DataSerializers.FLOAT);
     private static final DataParameter<Integer> POTION_EFFECTS = EntityDataManager.<Integer>createKey(EntityLivingBase.class, DataSerializers.VARINT);
     private static final DataParameter<Boolean> HIDE_PARTICLES = EntityDataManager.<Boolean>createKey(EntityLivingBase.class, DataSerializers.BOOLEAN);
     private static final DataParameter<Integer> ARROW_COUNT_IN_ENTITY = EntityDataManager.<Integer>createKey(EntityLivingBase.class, DataSerializers.VARINT);
     private AbstractAttributeMap attributeMap;
-    private final CombatTracker _combatTracker = new CombatTracker(this);
-    private final Map<Potion, PotionEffect> activePotionsMap = Maps.<Potion, PotionEffect>newHashMap();
+    public CombatTracker _combatTracker = new CombatTracker(this);
+    public final Map<Potion, PotionEffect> activePotionsMap = Maps.<Potion, PotionEffect>newHashMap(); // Spigot
     private final NonNullList<ItemStack> handInventory = NonNullList.<ItemStack>withSize(2, ItemStack.EMPTY);
     private final NonNullList<ItemStack> armorArray = NonNullList.<ItemStack>withSize(4, ItemStack.EMPTY);
     public boolean isSwingInProgress;
@@ -117,8 +110,8 @@
     public float rotationYawHead;
     public float prevRotationYawHead;
     public float jumpMovementFactor = 0.02F;
-    protected EntityPlayer attackingPlayer;
-    protected int recentlyHit;
+    public EntityPlayer attackingPlayer;
+    public int recentlyHit; // Paper - public
     protected boolean dead;
     protected int idleTime;
     protected float prevOnGroundSpeedFactor;
@@ -127,7 +120,7 @@
     protected float prevMovedDistance;
     protected float unused180;
     protected int scoreValue;
-    protected float lastDamage;
+    public float lastDamage;
     protected boolean isJumping;
     public float moveStrafing;
     public float moveVertical;
@@ -139,9 +132,9 @@
     protected double interpTargetZ;
     protected double interpTargetYaw;
     protected double interpTargetPitch;
-    private boolean potionsNeedUpdate = true;
-    private EntityLivingBase revengeTarget;
-    private int revengeTimer;
+    public boolean potionsNeedUpdate = true;
+    public EntityLivingBase revengeTarget;
+    public int revengeTimer;
     private EntityLivingBase lastAttackedEntity;
     private int lastAttackedEntityTime;
     private float landMovementFactor;
@@ -154,6 +147,26 @@
     private DamageSource lastDamageSource;
     private long lastDamageStamp;
 
+    // CraftBukkit start
+    public int expToDrop;
+    public int maxAirTicks = 300;
+    public boolean forceDrops;
+    public ArrayList<org.bukkit.inventory.ItemStack> drops = new ArrayList<>();
+    public CraftAttributeMap craftAttributes;
+    public boolean collides = true;
+    public boolean canPickUpLoot;
+    // CraftBukkit end
+    public boolean silentDeath = false; // Paper - mark entity as dying silently for cancellable death event
+
+
+    // Spigot start
+    public void inactiveTick()
+    {
+        super.inactiveTick();
+        ++this.idleTime; // Above all the floats
+    }
+    // Spigot end
+
     public void onKillCommand()
     {
         this.attackEntityFrom(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE);
@@ -163,7 +176,9 @@
     {
         super(worldIn);
         this.applyEntityAttributes();
-        this.setHealth(this.getMaxHealth());
+        // CraftBukkit - setHealth(getMaxHealth()) inlined and simplified to skip the instanceof check for EntityPlayer, as getBukkitEntity() is not initialized in constructor
+        // this.setHealth(this.getMaxHealth());
+        this.dataManager.set(EntityLiving.HEALTH, (float) this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).getAttributeValue());
         this.preventEntitySpawning = true;
         this.randomUnused1 = (float)((Math.random() + 1.0D) * 0.009999999776482582D);
         this.setPosition(this.posX, this.posY, this.posZ);
@@ -207,8 +222,17 @@
             {
                 double d0 = Math.min((double)(0.2F + f / 15.0F), 2.5D);
                 int i = (int)(150.0D * d0);
-                if (!state.getBlock().addLandingEffects(state, (WorldServer)this.world, pos, state, this, i))
-                ((WorldServer)this.world).spawnParticle(EnumParticleTypes.BLOCK_DUST, this.posX, this.posY, this.posZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, Block.getStateId(state));
+                if (!state.getBlock().addLandingEffects(state, (WorldServer)this.world, pos, state, this, i)) {
+                    // ((WorldServer) this.world).spawnParticle(EnumParticleTypes.BLOCK_DUST, this.posX, this.posY, this.posZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, Block.getStateId(state));
+                    // TODO: Is it correct to perform this code inside this if-statement?
+                    // CraftBukkit start - visiblity api
+                    if (this instanceof EntityPlayer) {
+                        ((WorldServer) this.world).sendParticles((EntityPlayerMP) this, EnumParticleTypes.BLOCK_DUST, false, this.posX, this.posY, this.posZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, new int[]{Block.getStateId(state)});
+                    } else {
+                        ((WorldServer) this.world).spawnParticle(EnumParticleTypes.BLOCK_DUST, this.posX, this.posY, this.posZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, new int[]{Block.getStateId(state)});
+                    }
+                    // CraftBukkit end
+                }
             }
         }
 
@@ -258,9 +282,13 @@
 
         if (this.isEntityAlive())
         {
-            if (!this.isInsideOfMaterial(Material.WATER))
-            {
-                this.setAir(300);
+            if (!this.isInsideOfMaterial(Material.WATER)) {
+                // this.setAir(300);
+                // CraftBukkit start - Only set if needed to work around a DataWatcher inefficiency
+                if (this.getAir() != 300) {
+                    this.setAir(maxAirTicks);
+                }
+                // CraftBukkit end
             }
             else
             {
@@ -359,6 +387,18 @@
         this.world.profiler.endSection();
     }
 
+    // CraftBukkit start
+    public int getExpReward() {
+        int exp = this.getExperiencePoints(this.attackingPlayer);
+
+        if (!this.world.isRemote && (this.recentlyHit > 0 || this.isPlayer()) && this.canDropLoot() && this.world.getGameRules().getBoolean("doMobLoot")) {
+            return exp;
+        } else {
+            return 0;
+        }
+    }
+    // CraftBukkit end
+
     protected void frostWalk(BlockPos pos)
     {
         int i = EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.FROST_WALKER, this);
@@ -378,19 +418,19 @@
     {
         ++this.deathTime;
 
-        if (this.deathTime == 20)
+        if (this.deathTime >= 20 && !this.isDead) // CraftBukkit - (this.deathTime == 20) -> (this.deathTime >= 20 && !this.isDead)
         {
-            if (!this.world.isRemote && (this.isPlayer() || this.recentlyHit > 0 && this.canDropLoot() && this.world.getGameRules().getBoolean("doMobLoot")))
-            {
-                int i = this.getExperiencePoints(this.attackingPlayer);
+            // if (!this.world.isRemote && (this.isPlayer() || this.recentlyHit > 0 && this.canDropLoot() && this.world.getGameRules().getBoolean("doMobLoot"))) {
+                int i = this.expToDrop;
                 i = net.minecraftforge.event.ForgeEventFactory.getExperienceDrop(this, this.attackingPlayer, i);
                 while (i > 0)
                 {
                     int j = EntityXPOrb.getXPSplit(i);
                     i -= j;
-                    this.world.spawnEntity(new EntityXPOrb(this.world, this.posX, this.posY, this.posZ, j));
+                    EntityLivingBase attacker = attackingPlayer != null ? attackingPlayer : revengeTarget; // Paper
+                    this.world.spawnEntity(new EntityXPOrb(this.world, this.posX, this.posY, this.posZ, j,this instanceof EntityPlayerMP ? org.bukkit.entity.ExperienceOrb.SpawnReason.PLAYER_DEATH : org.bukkit.entity.ExperienceOrb.SpawnReason.ENTITY_DEATH, attacker, this)); // Paper
                 }
-            }
+            this.expToDrop = 0;
 
             this.setDead();
 
@@ -445,6 +485,7 @@
     {
         this.revengeTarget = livingBase;
         this.revengeTimer = this.ticksExisted;
+        net.minecraftforge.common.ForgeHooks.onLivingSetAttackTarget(this, livingBase);
     }
 
     public EntityLivingBase getLastAttackedEntity()
@@ -543,7 +584,13 @@
 
     public void readEntityFromNBT(NBTTagCompound compound)
     {
-        this.setAbsorptionAmount(compound.getFloat("AbsorptionAmount"));
+        // Paper start - jvm keeps optimizing the setter
+        float absorptionAmount = compound.getFloat("AbsorptionAmount");
+        if (Float.isNaN(absorptionAmount)) {
+            absorptionAmount = 0;
+        }
+        this.setAbsorptionAmount(absorptionAmount);
+        // Paper end
 
         if (compound.hasKey("Attributes", 9) && this.world != null && !this.world.isRemote)
         {
@@ -566,6 +613,17 @@
             }
         }
 
+        // CraftBukkit start
+        if (compound.hasKey("Bukkit.MaxHealth")) {
+            NBTBase nbtbase = compound.getTag("Bukkit.MaxHealth");
+            if (nbtbase.getId() == 5) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(((NBTTagFloat) nbtbase).getDouble());
+            } else if (nbtbase.getId() == 3) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(((NBTTagInt) nbtbase).getDouble());
+            }
+        }
+        // CraftBukkit end
+
         if (compound.hasKey("Health", 99))
         {
             this.setHealth(compound.getFloat("Health"));
@@ -592,9 +650,15 @@
         }
     }
 
+    // CraftBukkit start
+    private boolean isTickingEffects = false;
+    private List<Object> effectsToProcess = Lists.newArrayList();
+    // CraftBukkit end
+
     protected void updatePotionEffects()
     {
         Iterator<Potion> iterator = this.activePotionsMap.keySet().iterator();
+        isTickingEffects = true; // CraftBukkit
 
         try
         {
@@ -622,6 +686,18 @@
             ;
         }
 
+        // CraftBukkit start
+        isTickingEffects = false;
+        for (Object e : effectsToProcess) {
+            if (e instanceof PotionEffect) {
+                addPotionEffect((PotionEffect) e);
+            } else {
+                removePotionEffect((Potion) e);
+            }
+        }
+        effectsToProcess.clear();
+        // CraftBukkit end
+
         if (this.potionsNeedUpdate)
         {
             if (!this.world.isRemote)
@@ -712,6 +788,7 @@
                 if(net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.living.PotionEvent.PotionRemoveEvent(this, effect))) continue;
 
                 this.onFinishedPotionEffect(effect);
+
                 iterator.remove();
             }
         }
@@ -740,6 +817,12 @@
 
     public void addPotionEffect(PotionEffect potioneffectIn)
     {
+        // CraftBukkit start
+        if (isTickingEffects) {
+            effectsToProcess.add(potioneffectIn);
+            return;
+        }
+        // CraftBukkit end
         if (this.isPotionApplicable(potioneffectIn))
         {
             PotionEffect potioneffect = this.activePotionsMap.get(potioneffectIn.getPotion());
@@ -784,6 +867,12 @@
     @Nullable
     public PotionEffect removeActivePotionEffect(@Nullable Potion potioneffectin)
     {
+        // CraftBukkit start
+        if (isTickingEffects) {
+            effectsToProcess.add(potioneffectin);
+            return null;
+        }
+        // CraftBukkit end
         return this.activePotionsMap.remove(potioneffectin);
     }
 
@@ -830,25 +919,67 @@
         }
     }
 
+    // CraftBukkit start - Delegate so we can handle providing a reason for health being regained
     public void heal(float healAmount)
     {
+        heal(healAmount, EntityRegainHealthEvent.RegainReason.CUSTOM);
+    }
+
+    public void heal(float healAmount, EntityRegainHealthEvent.RegainReason regainReason) {
+        // Paper start - Forward
+        heal(healAmount, regainReason, false);
+    }
+
+    public void heal(float healAmount, EntityRegainHealthEvent.RegainReason regainReason, boolean isFastRegen) {
+        // Paper end
         healAmount = net.minecraftforge.event.ForgeEventFactory.onLivingHeal(this, healAmount);
         if (healAmount <= 0) return;
         float f = this.getHealth();
 
         if (f > 0.0F)
         {
-            this.setHealth(f + healAmount);
+            // this.setHealth(f + healAmount);
+            EntityRegainHealthEvent event = new EntityRegainHealthEvent(this.getBukkitEntity(), healAmount, regainReason, isFastRegen); // Paper - Add isFastRegen
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (!event.isCancelled()) {
+                this.setHealth((float) (this.getHealth() + event.getAmount()));
+            }
         }
     }
 
     public final float getHealth()
     {
+        // CraftBukkit start - Use unscaled health
+        if (this instanceof EntityPlayer) {
+            return (float) ((EntityPlayer) this).getBukkitEntity().getHealth();
+        }
+        // CraftBukkit end
         return ((Float)this.dataManager.get(HEALTH)).floatValue();
     }
 
     public void setHealth(float health)
     {
+        // Paper start
+        if (Float.isNaN(health)) { health = getMaxHealth(); if (this.valid) {
+            System.err.println("[NAN-HEALTH] " + getName() + " had NaN health set");
+        } } // Paper end
+        // CraftBukkit start - Handle scaled health
+        if (this instanceof EntityPlayerMP && ((EntityPlayerMP)this).getGameProfile() != null) {
+            CraftPlayer player = ((EntityPlayerMP) this).getBukkitEntity();
+            // Squeeze
+            if (health < 0.0F) {
+                player.setRealHealth(0.0D);
+            } else if (health > player.getMaxHealth()) {
+                player.setRealHealth(player.getMaxHealth());
+            } else {
+                player.setRealHealth(health);
+            }
+
+            player.updateScaledHealth();
+            return;
+        }
+        // CraftBukkit end
         this.dataManager.set(HEALTH, Float.valueOf(MathHelper.clamp(health, 0.0F, this.getMaxHealth())));
     }
 
@@ -879,15 +1010,17 @@
             {
                 float f = amount;
 
-                if ((source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) && !this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty())
+                // CraftBukkit - Moved into damageEntity_CB(DamageSource, float)
+                if (false && (source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) && !this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty())
                 {
                     this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).damageItem((int)(amount * 4.0F + this.rand.nextFloat() * amount * 2.0F), this);
                     amount *= 0.75F;
                 }
 
-                boolean flag = false;
+                boolean flag = amount > 0.0F && this.canBlockDamageSource(source); // Copied from below
 
-                if (amount > 0.0F && this.canBlockDamageSource(source))
+                // CraftBukkit - Moved into damageEntity0(DamageSource, float)
+                if (false && amount > 0.0F && this.canBlockDamageSource(source))
                 {
                     this.damageShield(amount);
                     amount = 0.0F;
@@ -912,22 +1045,42 @@
                 {
                     if (amount <= this.lastDamage)
                     {
+                        this.forceExplosionKnockback = true; // CraftBukkit - SPIGOT-949 - for vanilla consistency, cooldown does not prevent explosion knockback
                         return false;
                     }
 
-                    this.damageEntity(source, amount - this.lastDamage);
+                    // CraftBukkit start
+                    if (!this.damageEntity_CB(source, amount - this.lastDamage)) {
+                        return false;
+                    }
+                    // CraftBukkit end
                     this.lastDamage = amount;
                     flag1 = false;
                 }
                 else
                 {
+                    // CraftBukkit start
+                    if (!this.damageEntity_CB(source, amount)) {
+                        return false;
+                    }
+                    // CraftBukkit end
                     this.lastDamage = amount;
                     this.hurtResistantTime = this.maxHurtResistantTime;
-                    this.damageEntity(source, amount);
                     this.maxHurtTime = 10;
                     this.hurtTime = this.maxHurtTime;
                 }
 
+                // CraftBukkit start
+                if (this instanceof EntityAnimal) {
+                    ((EntityAnimal) this).resetInLove();
+                    if (this instanceof EntityTameable) {
+                        if (((EntityTameable) this).getAISit() == null)
+                            ((EntityTameable) this).setAISit(new EntityAISit((EntityTameable) this));
+                        ((EntityTameable) this).getAISit().setSitting(false);
+                    }
+                }
+                // CraftBukkit end
+
                 this.attackedAtYaw = 0.0F;
                 Entity entity1 = source.getTrueSource();
 
@@ -943,9 +1096,9 @@
                         this.recentlyHit = 100;
                         this.attackingPlayer = (EntityPlayer)entity1;
                     }
-                    else if (entity1 instanceof net.minecraft.entity.passive.EntityTameable)
+                    else if (entity1 instanceof EntityTameable)
                     {
-                        net.minecraft.entity.passive.EntityTameable entitywolf = (net.minecraft.entity.passive.EntityTameable)entity1;
+                        EntityTameable entitywolf = (EntityTameable)entity1;
 
                         if (entitywolf.isTamed())
                         {
@@ -955,6 +1108,7 @@
                     }
                 }
 
+                boolean knockbackCancelled = world.paperConfig.disableExplosionKnockback && source.isExplosion() && this instanceof EntityPlayer; // Paper - Disable explosion knockback
                 if (flag1)
                 {
                     if (flag)
@@ -982,6 +1136,7 @@
                             b0 = 2;
                         }
 
+                        if (!knockbackCancelled) // Paper - Disable explosion knockback
                         this.world.setEntityState(this, b0);
                     }
 
@@ -1009,18 +1164,15 @@
                     }
                 }
 
+                if (knockbackCancelled) this.world.setEntityState(this, (byte) 2); // Paper - Disable explosion knockback
                 if (this.getHealth() <= 0.0F)
                 {
                     if (!this.checkTotemDeathProtection(source))
                     {
-                        SoundEvent soundevent = this.getDeathSound();
+                        this.silentDeath = !flag1; // mark entity as dying silently
 
-                        if (flag1 && soundevent != null)
-                        {
-                            this.playSound(soundevent, this.getSoundVolume(), this.getSoundPitch());
-                        }
-
                         this.onDeath(source);
+                        this.silentDeath = false; // Paper - cancellable death event - reset to default
                     }
                 }
                 else if (flag1)
@@ -1065,22 +1217,30 @@
         else
         {
             ItemStack itemstack = null;
+            // CraftBukkit start
+            ItemStack itemstack1 = ItemStack.EMPTY;
 
             for (EnumHand enumhand : EnumHand.values())
             {
-                ItemStack itemstack1 = this.getHeldItem(enumhand);
+                itemstack1 = this.getHeldItem(enumhand);
 
                 if (itemstack1.getItem() == Items.TOTEM_OF_UNDYING)
                 {
                     itemstack = itemstack1.copy();
-                    itemstack1.shrink(1);
+//                    itemstack1.shrink(1); // CraftBukkit
                     break;
                 }
             }
 
-            if (itemstack != null)
-            {
-                if (this instanceof EntityPlayerMP)
+            EntityResurrectEvent event = new EntityResurrectEvent((LivingEntity) this.getBukkitEntity());
+            event.setCancelled(itemstack == null);
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (!event.isCancelled()) {
+                if (!itemstack1.isEmpty()) {
+                    itemstack1.shrink(1);
+                }
+                if (itemstack != null && this instanceof EntityPlayerMP)
                 {
                     EntityPlayerMP entityplayermp = (EntityPlayerMP)this;
                     entityplayermp.addStat(StatList.getObjectUseStats(Items.TOTEM_OF_UNDYING));
@@ -1094,7 +1254,8 @@
                 this.world.setEntityState(this, (byte)35);
             }
 
-            return itemstack != null;
+//            return itemstack != null;
+            return !event.isCancelled();
         }
     }
 
@@ -1171,19 +1332,8 @@
             Entity entity = cause.getTrueSource();
             EntityLivingBase entitylivingbase = this.getAttackingEntity();
 
-            if (this.scoreValue >= 0 && entitylivingbase != null)
-            {
-                entitylivingbase.awardKillScore(this, this.scoreValue, cause);
-            }
-
-            if (entity != null)
-            {
-                entity.onKillEntity(this);
-            }
-
             this.dead = true;
-            this.getCombatTracker().reset();
-
+            org.bukkit.event.entity.EntityDeathEvent deathEvent = null;
             if (!this.world.isRemote)
             {
                 int i = net.minecraftforge.common.ForgeHooks.getLootingLevel(this, entity, cause);
@@ -1196,11 +1346,25 @@
                     boolean flag = this.recentlyHit > 0;
                     this.dropLoot(flag, i, cause);
                 }
-
+                
                 captureDrops = false;
 
                 if (!net.minecraftforge.common.ForgeHooks.onLivingDrops(this, cause, capturedDrops, i, recentlyHit > 0))
                 {
+                    if (this.capturedDrops.size() > 0)
+                    {
+                      for(EntityItem item: capturedDrops)
+                      {
+                          this.drops.add(CraftItemStack.asCraftMirror(item.getItem()));
+                      }
+                        deathEvent = CraftEventFactory.callEntityDeathEvent(this, this.drops); // Paper - cancellable death event
+                    }
+                    else
+                    {
+                        deathEvent = CraftEventFactory.callEntityDeathEvent(this); // Paper - cancellable death event
+                        // CraftBukkit end
+                	}
+                	
                     for (EntityItem item : capturedDrops)
                     {
                         world.spawnEntity(item);
@@ -1208,7 +1372,25 @@
                 }
             }
 
+            // Paper start - cancellable death event
+            if (deathEvent == null || !deathEvent.isCancelled()) {
+                // triggers and stats got moved down
+                if (this.scoreValue >= 0 && entitylivingbase != null) {
+                    entitylivingbase.awardKillScore(this, this.scoreValue, cause);
+                }
+
+                if (entity != null) {
+                    entity.onKillEntity(this);
+                }
+
+                this.getCombatTracker().reset();
+                this.dead = true;
             this.world.setEntityState(this, (byte)3);
+            } else {
+                this.dead = false; // Paper - reset if cancelled
+                this.setHealth((float) deathEvent.getReviveHealth());
+            }
+            // Paper end
         }
     }
 
@@ -1231,6 +1413,13 @@
         {
             this.isAirBorne = true;
             float f = MathHelper.sqrt(xRatio * xRatio + zRatio * zRatio);
+
+            // Paper start - preserve old velocity
+            double oldMotX = this.motionX;
+            double oldMotY = this.motionY;
+            double oldMotZ = this.motionZ;
+            // Paper end
+
             this.motionX /= 2.0D;
             this.motionZ /= 2.0D;
             this.motionX -= xRatio / (double)f * (double)strength;
@@ -1246,6 +1435,19 @@
                     this.motionY = 0.4000000059604645D;
                 }
             }
+
+            // Paper start - call EntityKnockbackByEntityEvent
+            org.bukkit.util.Vector delta = new org.bukkit.util.Vector(this.motionX - oldMotX, this.motionY - oldMotY, this.motionZ - oldMotZ);
+            // Restore old velocity to be able to access it in the event
+            this.motionX = oldMotX;
+            this.motionY = oldMotY;
+            this.motionZ = oldMotZ;
+            if (entityIn == null || new com.destroystokyo.paper.event.entity.EntityKnockbackByEntityEvent((LivingEntity) getBukkitEntity(), entityIn.getBukkitEntity(), f, delta).callEvent()) {
+                this.motionX += delta.getX();
+                this.motionY += delta.getY();
+                this.motionZ += delta.getZ();
+            }
+            // Paper end
         }
     }
 
@@ -1255,6 +1457,7 @@
         return SoundEvents.ENTITY_GENERIC_HURT;
     }
 
+    @Nullable public SoundEvent getDeathSoundEffect() { return getDeathSound();} // Paper - OBFHELPER
     @Nullable
     protected SoundEvent getDeathSound()
     {
@@ -1321,8 +1524,13 @@
 
         if (i > 0)
         {
+            // CraftBukkit start
+            if (!this.attackEntityFrom(DamageSource.FALL, (float) i)) {
+                return;
+            }
+            // CraftBukkit end
             this.playSound(this.getFallSound(i), 1.0F, 1.0F);
-            this.attackEntityFrom(DamageSource.FALL, (float)i);
+//            this.attackEntityFrom(DamageSource.FALL, (float)i); // CraftBukkit - moved up
             int j = MathHelper.floor(this.posX);
             int k = MathHelper.floor(this.posY - 0.20000000298023224D);
             int l = MathHelper.floor(this.posZ);
@@ -1362,7 +1570,7 @@
     {
         if (!source.isUnblockable())
         {
-            this.damageArmor(damage);
+//            this.damageArmor(damage); // CraftBukkit - Moved into damageEntity0(DamageSource, float)
             damage = CombatRules.getDamageAfterAbsorb(damage, (float)this.getTotalArmorValue(), (float)this.getEntityAttribute(SharedMonsterAttributes.ARMOR_TOUGHNESS).getAttributeValue());
         }
 
@@ -1377,7 +1585,8 @@
         }
         else
         {
-            if (this.isPotionActive(MobEffects.RESISTANCE) && source != DamageSource.OUT_OF_WORLD)
+            // CraftBukkit - Moved to damageEntity0(DamageSource, float)
+            if (false && this.isPotionActive(MobEffects.RESISTANCE) && source != DamageSource.OUT_OF_WORLD)
             {
                 int i = (this.getActivePotionEffect(MobEffects.RESISTANCE).getAmplifier() + 1) * 5;
                 int j = 25 - i;
@@ -1405,25 +1614,167 @@
 
     protected void damageEntity(DamageSource damageSrc, float damageAmount)
     {
-        if (!this.isEntityInvulnerable(damageSrc))
-        {
-            damageAmount = net.minecraftforge.common.ForgeHooks.onLivingHurt(this, damageSrc, damageAmount);
-            if (damageAmount <= 0) return;
-            damageAmount = this.applyArmorCalculations(damageSrc, damageAmount);
-            damageAmount = this.applyPotionDamageCalculations(damageSrc, damageAmount);
-            float f = damageAmount;
-            damageAmount = Math.max(damageAmount - this.getAbsorptionAmount(), 0.0F);
-            this.setAbsorptionAmount(this.getAbsorptionAmount() - (f - damageAmount));
-            damageAmount = net.minecraftforge.common.ForgeHooks.onLivingDamage(this, damageSrc, damageAmount);
+        this.damageEntity_CB(damageSrc, damageAmount);
+    }
 
-            if (damageAmount != 0.0F)
-            {
-                float f1 = this.getHealth();
-                this.getCombatTracker().trackDamage(damageSrc, f1, damageAmount);
-                this.setHealth(f1 - damageAmount); // Forge: moved to fix MC-121048
-                this.setAbsorptionAmount(this.getAbsorptionAmount() - damageAmount);
+    private EntityDamageEvent calculateDebuffsAndCallCB(final DamageSource damagesource, float f) {
+        final boolean human = this instanceof EntityPlayer;
+        final float originalDamage = f;
+        // Calculates the damage debuff that occurs when an entity has something on his/her head
+        Function<Double, Double> hardHat = f12 -> {
+            if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK)
+                    && EntityLivingBase.this.getItemStackFromSlot(EntityEquipmentSlot.HEAD) != null) {
+                // Saves you from 1/4 damage
+                return -(f12 * 0.25F);
             }
+            return -0.0;
+        };
+        float hardHatModifier = hardHat.apply((double) f).floatValue();
+        f += hardHatModifier;
+
+        // Calculates the damage debuff that occurs when a player is blocking and can block the damage source
+        Function<Double, Double> blocking = f13 -> -((EntityLivingBase.this.canBlockDamageSource(damagesource)) ? f13 : 0.0);
+        float blockingModifier = blocking.apply((double) f).floatValue();
+        f += blockingModifier;
+
+        // Calculates the damage debuff that occurs when a player (or entity) is wearing armor...this is damn problematic
+        Function<Double, Double> armor = f14 -> {
+            // Cauldron start - apply forge armor hook
+            if (human) {
+                return -(f14 - ISpecialArmor.ArmorProperties.ApplyArmor(EntityLivingBase.this, ((EntityPlayer) EntityLivingBase.this).inventory.armorInventory, damagesource, f14.floatValue(), false));
+            }
+            // Cauldron end
+            return -(f14 - EntityLivingBase.this.applyArmorCalculations(damagesource, f14.floatValue()));
+        };
+        float armorModifier = armor.apply((double) f).floatValue();
+        f += armorModifier;
+
+        // Calculates potion effect debuffs
+        Function<Double, Double> resistance = f15 -> {
+            if (!damagesource.isDamageAbsolute() && EntityLivingBase.this.isPotionActive(MobEffects.RESISTANCE) && damagesource != DamageSource.OUT_OF_WORLD) {
+                int i = (EntityLivingBase.this.getActivePotionEffect(MobEffects.RESISTANCE).getAmplifier() + 1) * 5;
+                int j = 25 - i;
+                float f1 = f15.floatValue() * (float) j;
+                return -(f15 - (f1 / 25.0F));
+            }
+            return -0.0;
+        };
+        float resistanceModifier = resistance.apply((double) f).floatValue();
+        f += resistanceModifier;
+
+        // Calculates other potion effect debuffs
+        Function<Double, Double> magic = new Function<Double, Double>() {
+            @Override
+            public Double apply(Double f) {
+                return -(f - EntityLivingBase.this.applyPotionDamageCalculations(damagesource, f.floatValue()));
+            }
+        };
+        float magicModifier = magic.apply((double) f).floatValue();
+        f += magicModifier;
+
+        // Calculates "damage absorption ability" debuffs
+        Function<Double, Double> absorption = new Function<Double, Double>() {
+            @Override
+            public Double apply(Double f) {
+                return -(Math.max(f - Math.max(f - EntityLivingBase.this.getAbsorptionAmount(), 0.0F), 0.0F));
+            }
+        };
+        float absorptionModifier = absorption.apply((double) f).floatValue();
+
+        EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
+
+        return event;
+    }
+
+    // CraftBukkit start
+    protected boolean damageEntity_CB(final DamageSource damagesource, float f) { // void -> boolean, add final
+        if (!this.isEntityInvulnerable(damagesource)) {
+            // Check if entity is a "human" aka player
+            final boolean human = this instanceof EntityPlayer;
+            final float originalDamage = f;
+            // Cauldron start - apply forge damage hook
+            f = ForgeHooks.onLivingHurt(this, damagesource, f);
+            // If the damage is negative return true
+            if (f < 0) return true;
+            // Thermos detect null damage
+            final boolean nulldmg = f == 0;
+            // Cauldron end
+
+            EntityDamageEvent ede = calculateDebuffsAndCallCB(damagesource, f);
+
+            if (ede.isCancelled()) {
+                return false;
+            }
+            f = (float) ede.getFinalDamage();
+
+            if (nulldmg) return true; // Preclude any stupidity with null head items
+
+            // Apply damage to helmet
+            if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK) && this.getItemStackFromSlot(EntityEquipmentSlot.HEAD) != null) {
+                this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).damageItem((int) (ede.getDamage() * 4.0F + this.rand.nextFloat() * ede.getDamage() * 2.0F), this);
+            }
+
+            // Apply damage to armor
+            if (!damagesource.isUnblockable()) {
+                float armorDamage = (float) (ede.getDamage() + ede.getDamage(EntityDamageEvent.DamageModifier.BLOCKING) + ede.getDamage(EntityDamageEvent.DamageModifier.HARD_HAT));
+                if (human) {
+                    EntityPlayer player = (EntityPlayer) this;
+                    armorDamage = ISpecialArmor.ArmorProperties.ApplyArmor(player, player.inventory.armorInventory, damagesource, armorDamage, true);
+                } else {
+                    this.damageArmor(armorDamage);
+                }
+
+                // Thermos AVOID DAMAGE if armor nullifies it (CraftBukkit failed to include this, this is why TFC bug happened)
+                if (armorDamage <= 0) return true;
+            }
+
+            // Apply blocking code // PAIL: steal from above
+            if (ede.getDamage(EntityDamageEvent.DamageModifier.BLOCKING) < 0) {
+                this.damageShield((float) -ede.getDamage(EntityDamageEvent.DamageModifier.BLOCKING));
+                Entity entity = damagesource.getImmediateSource();
+
+                if (entity instanceof EntityLivingBase) {
+                    this.blockUsingShield((EntityLivingBase) entity);
+                }
+            }
+
+            float absorptionModifier = (float) -ede.getDamage(EntityDamageEvent.DamageModifier.ABSORPTION);
+            this.setAbsorptionAmount(Math.max(this.getAbsorptionAmount() - absorptionModifier, 0.0F));
+            if (f != 0.0F || !human) {
+                if (human) {
+                    ((EntityPlayer) this).addExhaustion(damagesource.getHungerDamage());
+                }
+                // CraftBukkit end
+                float f2 = this.getHealth();
+
+                this.setHealth(f2 - f);
+                this.getCombatTracker().trackDamage(damagesource, f2, f);
+                // CraftBukkit start
+                if (!human) {
+                    this.setAbsorptionAmount(this.getAbsorptionAmount() - f);
+                }
+                // CraftBukkit end
+                // CraftBukkit start
+                return true;
+            }else {
+                // Duplicate triggers if blocking
+                if (ede.getDamage(EntityDamageEvent.DamageModifier.BLOCKING) < 0) {
+                    if (this instanceof EntityPlayerMP) {
+                        CriteriaTriggers.ENTITY_HURT_PLAYER.trigger((EntityPlayerMP) this, damagesource, f, originalDamage, true);
+                    }
+
+                    if (damagesource.getTrueSource() instanceof EntityPlayerMP) {
+                        CriteriaTriggers.PLAYER_HURT_ENTITY.trigger((EntityPlayerMP) damagesource.getTrueSource(), this, damagesource, f, originalDamage, true);
+                    }
+
+                    return false;
+                } else {
+                    return originalDamage > 0;
+                }
+                // CraftBukkit end
+            }
         }
+        return false; // CraftBukkit
     }
 
     public CombatTracker getCombatTracker()
@@ -1605,6 +1956,7 @@
         if (this.attributeMap == null)
         {
             this.attributeMap = new AttributeMap();
+            this.craftAttributes = new CraftAttributeMap(attributeMap); // CraftBukkit
         }
 
         return this.attributeMap;
@@ -1685,11 +2037,13 @@
         }
     }
 
+    public float getDeathSoundVolume() { return getSoundVolume();} // Paper - OBFHELPER
     protected float getSoundVolume()
     {
         return 1.0F;
     }
 
+    public float getDeathSoundPitch() { return getSoundPitch();} // Paper - OBFHELPER
     protected float getSoundPitch()
     {
         return this.isChild() ? (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.5F : (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F;
@@ -1844,63 +2198,66 @@
                 {
                     if (this.isElytraFlying())
                     {
-                        if (this.motionY > -0.5D)
-                        {
-                            this.fallDistance = 1.0F;
-                        }
+                        if (world.paperConfig.elytraHitWallDamage) { // Paper start - Toggleable Elytra Wall Damage
+                            if (this.motionY > -0.5D)
+                            {
+                                this.fallDistance = 1.0F;
+                            }
 
-                        Vec3d vec3d = this.getLookVec();
-                        float f = this.rotationPitch * 0.017453292F;
-                        double d6 = Math.sqrt(vec3d.x * vec3d.x + vec3d.z * vec3d.z);
-                        double d8 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-                        double d1 = vec3d.lengthVector();
-                        float f4 = MathHelper.cos(f);
-                        f4 = (float)((double)f4 * (double)f4 * Math.min(1.0D, d1 / 0.4D));
-                        this.motionY += -0.08D + (double)f4 * 0.06D;
+                            Vec3d vec3d = this.getLookVec();
+                            float f = this.rotationPitch * 0.017453292F;
+                            double d6 = Math.sqrt(vec3d.x * vec3d.x + vec3d.z * vec3d.z);
+                            double d8 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+                            double d1 = vec3d.lengthVector();
+                            float f4 = MathHelper.cos(f);
+                            f4 = (float)((double)f4 * (double)f4 * Math.min(1.0D, d1 / 0.4D));
+                            this.motionY += -0.08D + (double)f4 * 0.06D;
 
-                        if (this.motionY < 0.0D && d6 > 0.0D)
-                        {
-                            double d2 = this.motionY * -0.1D * (double)f4;
-                            this.motionY += d2;
-                            this.motionX += vec3d.x * d2 / d6;
-                            this.motionZ += vec3d.z * d2 / d6;
-                        }
+                            if (this.motionY < 0.0D && d6 > 0.0D)
+                            {
+                                double d2 = this.motionY * -0.1D * (double)f4;
+                                this.motionY += d2;
+                                this.motionX += vec3d.x * d2 / d6;
+                                this.motionZ += vec3d.z * d2 / d6;
+                            }
 
-                        if (f < 0.0F)
-                        {
-                            double d10 = d8 * (double)(-MathHelper.sin(f)) * 0.04D;
-                            this.motionY += d10 * 3.2D;
-                            this.motionX -= vec3d.x * d10 / d6;
-                            this.motionZ -= vec3d.z * d10 / d6;
-                        }
+                            if (f < 0.0F)
+                            {
+                                double d10 = d8 * (double)(-MathHelper.sin(f)) * 0.04D;
+                                this.motionY += d10 * 3.2D;
+                                this.motionX -= vec3d.x * d10 / d6;
+                                this.motionZ -= vec3d.z * d10 / d6;
+                            }
 
-                        if (d6 > 0.0D)
-                        {
-                            this.motionX += (vec3d.x / d6 * d8 - this.motionX) * 0.1D;
-                            this.motionZ += (vec3d.z / d6 * d8 - this.motionZ) * 0.1D;
-                        }
+                            if (d6 > 0.0D)
+                            {
+                                this.motionX += (vec3d.x / d6 * d8 - this.motionX) * 0.1D;
+                                this.motionZ += (vec3d.z / d6 * d8 - this.motionZ) * 0.1D;
+                            }
 
-                        this.motionX *= 0.9900000095367432D;
-                        this.motionY *= 0.9800000190734863D;
-                        this.motionZ *= 0.9900000095367432D;
-                        this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
+                            this.motionX *= 0.9900000095367432D;
+                            this.motionY *= 0.9800000190734863D;
+                            this.motionZ *= 0.9900000095367432D;
+                            this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
 
-                        if (this.collidedHorizontally && !this.world.isRemote)
-                        {
-                            double d11 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-                            double d3 = d8 - d11;
-                            float f5 = (float)(d3 * 10.0D - 3.0D);
-
-                            if (f5 > 0.0F)
+                            if (this.collidedHorizontally && !this.world.isRemote)
                             {
-                                this.playSound(this.getFallSound((int)f5), 1.0F, 1.0F);
-                                this.attackEntityFrom(DamageSource.FLY_INTO_WALL, f5);
+                                double d11 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
+                                double d3 = d8 - d11;
+                                float f5 = (float)(d3 * 10.0D - 3.0D);
+
+                                if (f5 > 0.0F)
+                                {
+                                    this.playSound(this.getFallSound((int)f5), 1.0F, 1.0F);
+                                    this.attackEntityFrom(DamageSource.FLY_INTO_WALL, f5);
+                                }
                             }
-                        }
+                        } // Paper end - Elyta Wall Damage if statement
 
                         if (this.onGround && !this.world.isRemote)
                         {
-                            this.setFlag(7, false);
+                            if (getFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, false).isCancelled())
+                                this.setFlag(7, false);
                         }
                     }
                     else
@@ -2135,6 +2492,13 @@
 
                 if (!ItemStack.areItemStacksEqual(itemstack1, itemstack))
                 {
+                    // Paper start - PlayerArmorChangeEvent
+                    if (this instanceof EntityPlayer && entityequipmentslot.getType() == Type.ARMOR) {
+                        final org.bukkit.inventory.ItemStack oldItem = CraftItemStack.asBukkitCopy(itemstack);
+                        final org.bukkit.inventory.ItemStack newItem = CraftItemStack.asBukkitCopy(itemstack1);
+                        new PlayerArmorChangeEvent((Player) this.getBukkitEntity(), PlayerArmorChangeEvent.SlotType.valueOf(entityequipmentslot.name()), oldItem, newItem).callEvent();
+                    }
+                    // Paper end
                     if (!ItemStack.areItemStacksEqualUsingNBTShareTag(itemstack1, itemstack))
                     ((WorldServer)this.world).getEntityTracker().sendToTracking(this, new SPacketEntityEquipment(this.getEntityId(), entityequipmentslot, itemstack1));
                     net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.living.LivingEquipmentChangeEvent(this, entityequipmentslot, itemstack, itemstack1));
@@ -2345,7 +2709,6 @@
         }
 
         this.world.profiler.startSection("ai");
-
         if (this.isMovementBlocked())
         {
             this.isJumping = false;
@@ -2426,6 +2789,7 @@
 
         if (!this.world.isRemote)
         {
+            if (flag != this.getFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, flag).isCancelled()) // CraftBukkit
             this.setFlag(7, flag);
         }
     }
@@ -2460,9 +2824,12 @@
                 }
             }
 
-            for (int l = 0; l < list.size(); ++l)
+            numCollisions = Math.max(0, numCollisions - world.paperConfig.maxCollisionsPerEntity); // Paper
+            for (int j = 0; j < list.size() && numCollisions < world.paperConfig.maxCollisionsPerEntity; ++j) // Paper
             {
-                Entity entity = list.get(l);
+                Entity entity = list.get(j);
+                entity.numCollisions++; // Paper
+                numCollisions++; // Paper
                 this.collideWithEntity(entity);
             }
         }
@@ -2560,12 +2927,12 @@
 
     public boolean canBeCollidedWith()
     {
-        return !this.isDead;
+        return !this.isDead && this.collides;
     }
 
     public boolean canBePushed()
     {
-        return this.isEntityAlive() && !this.isOnLadder();
+        return this.isEntityAlive() && !this.isOnLadder() && this.collides; // CraftBukkit
     }
 
     protected void markVelocityChanged()
@@ -2595,8 +2962,7 @@
 
     public void setAbsorptionAmount(float amount)
     {
-        if (amount < 0.0F)
-        {
+        if (amount < 0.0F || Float.isNaN(amount)) { // Paper
             amount = 0.0F;
         }
 
@@ -2629,7 +2995,7 @@
         {
             PotionEffect effect = iterator.next();
 
-            if (effect.isCurativeItem(curativeItem) && !net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.living.PotionEvent.PotionRemoveEvent(this, effect)))
+            if (effect.isCurativeItem(curativeItem) && !MinecraftForge.EVENT_BUS.post(new PotionRemoveEvent(this, effect)))
             {
                 onFinishedPotionEffect(effect);
                 iterator.remove();
@@ -2667,7 +3033,8 @@
         if (this.isHandActive())
         {
             ItemStack itemstack = this.getHeldItem(this.getActiveHand());
-            if (net.minecraftforge.common.ForgeHooks.canContinueUsing(this.activeItemStack, itemstack)) this.activeItemStack = itemstack;
+            if (net.minecraftforge.common.ForgeHooks.canContinueUsing(this.activeItemStack, itemstack))
+                this.activeItemStack = itemstack;
 
             if (itemstack == this.activeItemStack)
             {
@@ -2784,25 +3151,56 @@
     {
         if (!this.activeItemStack.isEmpty() && this.isHandActive())
         {
+            PlayerItemConsumeEvent event = null; // Paper
             this.updateItemUse(this.activeItemStack, 16);
-            ItemStack activeItemStackCopy = this.activeItemStack.copy();
-            ItemStack itemstack = this.activeItemStack.onItemUseFinish(this.world, this);
+            ItemStack itemstack = this.activeItemStack;
+
+            if (this instanceof EntityPlayer) {
+                org.bukkit.inventory.ItemStack craftItem = CraftItemStack.asBukkitCopy(itemstack);
+                event = new PlayerItemConsumeEvent((Player) this.getBukkitEntity(), craftItem); // Paper
+                world.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    // Update client
+                    ((EntityPlayerMP) this).getBukkitEntity().updateInventory();
+                    ((EntityPlayerMP) this).getBukkitEntity().updateScaledHealth();
+                    return;
+                }
+
+                itemstack = CraftItemStack.asNMSCopy(event.getItem());
+            }
+
+            ItemStack activeItemStackCopy = activeItemStack.copy();
+            itemstack = itemstack.onItemUseFinish(world, this);
             itemstack = net.minecraftforge.event.ForgeEventFactory.onItemUseFinish(this, activeItemStackCopy, getItemInUseCount(), itemstack);
+            // Paper start - save the default replacement item and change it if necessary
+            final ItemStack defaultReplacement = itemstack;
+            if (event != null && event.getReplacement() != null) {
+                itemstack = CraftItemStack.asNMSCopy(event.getReplacement());
+            }
+            // Paper end
             this.setHeldItem(this.getActiveHand(), itemstack);
             this.resetActiveHand();
+            // Paper start - if the replacement is anything but the default, update the client inventory
+            if (this instanceof EntityPlayerMP && !com.google.common.base.Objects.equal(defaultReplacement, itemstack)) {
+                ((EntityPlayerMP) this).getBukkitEntity().updateInventory();
+            }
         }
     }
 
+    public ItemStack getActiveItem() { return getActiveItemStack(); } // Paper - OBFHELPER
     public ItemStack getActiveItemStack()
     {
         return this.activeItemStack;
     }
 
+    public int getItemUseRemainingTime() { return getItemInUseCount(); } // Paper - OBFHELPER
     public int getItemInUseCount()
     {
         return this.activeItemStackUseCount;
     }
 
+    public int getHandRaisedTime() { return getItemInUseMaxCount(); } // Paper - OBFHELPER
     public int getItemInUseMaxCount()
     {
         return this.isHandActive() ? this.activeItemStack.getMaxItemUseDuration() - this.getItemInUseCount() : 0;
@@ -2842,7 +3240,7 @@
             }
             else
             {
-                return item.getMaxItemUseDuration(this.activeItemStack) - this.activeItemStackUseCount >= 5;
+                return item.getMaxItemUseDuration(this.activeItemStack) - this.activeItemStackUseCount >= getShieldBlockingDelay(); // Paper - shieldBlockingDelay
             }
         }
         else
@@ -2897,12 +3295,17 @@
 
             if (flag1)
             {
-                this.setPositionAndUpdate(this.posX, this.posY, this.posZ);
-
-                if (world.getCollisionBoxes(this, this.getEntityBoundingBox()).isEmpty() && !world.containsAnyLiquid(this.getEntityBoundingBox()))
-                {
-                    flag = true;
+                // CraftBukkit start - Teleport event
+                EntityTeleportEvent teleport = new EntityTeleportEvent(this.getBukkitEntity(), new Location(this.world.getWorld(), d0, d1, d2), new Location(this.world.getWorld(), this.posX, this.posY, this.posZ));
+                this.world.getServer().getPluginManager().callEvent(teleport);
+                if (!teleport.isCancelled()) {
+                    Location to = teleport.getTo();
+                    this.setPositionAndUpdate(to.getX(), to.getY(), to.getZ());
+                    if (world.getCollisionBoxes(this, this.getEntityBoundingBox()).isEmpty() && !world.containsAnyLiquid(this.getEntityBoundingBox())) {
+                        flag = true;
+                    }
                 }
+                // CraftBukkit end
             }
         }
 
@@ -2936,6 +3339,11 @@
         }
     }
 
+    @Override
+    public float getBukkitYaw() {
+        return getRotationYawHead();
+    }
+
     public boolean canBeHitWithPotion()
     {
         return true;
@@ -2949,7 +3357,7 @@
     @SuppressWarnings("unchecked")
     @Override
     @Nullable
-    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable net.minecraft.util.EnumFacing facing)
+    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable EnumFacing facing)
     {
         if (capability == net.minecraftforge.items.CapabilityItemHandler.ITEM_HANDLER_CAPABILITY)
         {
@@ -2961,7 +3369,7 @@
     }
 
     @Override
-    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable net.minecraft.util.EnumFacing facing)
+    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable EnumFacing facing)
     {
         return capability == net.minecraftforge.items.CapabilityItemHandler.ITEM_HANDLER_CAPABILITY || super.hasCapability(capability, facing);
     }
@@ -3001,4 +3409,14 @@
             this.motionZ += (double)(forward * f2 + strafe * f1);
         }
     }
+
+    // Paper start
+    public int shieldBlockingDelay = world.paperConfig.shieldBlockingDelay;
+    public int getShieldBlockingDelay() {
+        return shieldBlockingDelay;
+    }
+    public void setShieldBlockingDelay(int shieldBlockingDelay) {
+        this.shieldBlockingDelay = shieldBlockingDelay;
+    }
+    // Paper end
 }
